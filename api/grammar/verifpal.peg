{
/* SPDX-FileCopyrightText: Â© 2019-2020 Nadim Kobeissi <nadim@symbolic.software>
 * SPDX-License-Identifier: GPL-3.0-only */

// This file is generated automatically from verifpal.peg.
// Do not modify.

package verifpal

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

var parserReserved = []string{
	"attacker", "passive", "active", "principal",
	"phase, public", "private", "password",
	"confidentiality", "authentication", "precondition",
	"ringsign", "ringsignverif",
	"primitive", "pw_hash", "hash", "hkdf",
	"aead_enc", "aead_dec", "enc", "dec",
	"mac", "assert", "sign", "signverif",
	"pke_enc", "pke_dec", "shamir_split",
	"shamir_join", "concat", "split",
	"g", "nil", "unnamed",
}

func parserCheckIfReserved(s string) error {
	found := false
	switch {
	case strInSlice(s, parserReserved):
		found = true
	case strings.HasPrefix(s, "attacker"):
		found = true
	case strings.HasPrefix(s, "unnamed"):
		found = true
	}
	if found {
		return fmt.Errorf("cannot use reserved keyword in name: %s", s)
	}
	return nil
}

func parserParseModel(filePath string, verbose bool) Model {
	fileName := path.Base(filePath)
	if len(fileName) > 64 {
		errorCritical("model file name must be 64 characters or less")
	}
	if filepath.Ext(fileName) != ".vp" {
		errorCritical("model file name must have a '.vp' extension")
	}
	if verbose {
		PrettyInfo(fmt.Sprintf(
			"Parsing model '%s'...", fileName,
		), "verifpal", false)
	}
	parsed, err := ParseFile(filePath)
	if err != nil {
		errorCritical(err.Error())
	}
	m := parsed.(Model)
	m.fileName = fileName
	return m
}
}

Model <- Comment* Attacker:Attacker? Blocks:(Block+)? Queries:Queries? Comment* EOF {
	switch {
	case Attacker == nil:
		return nil, errors.New("no `attacker` block defined")
	case Blocks == nil:
		return nil, errors.New("no principal or message blocks defined")
	case Queries == nil:
		return nil, errors.New("no `queries` block defined")
	}
	b := Blocks.([]interface{})
	q := Queries.([]interface{})
	db := make([]block, len(b))
	dq := make([]query, len(q))
	for i, v := range b { db[i] = v.(block) }
	for i, v := range q { dq[i] = v.(query) }
	return Model{
		attacker: Attacker.(string),
		blocks: db,
		queries: dq,
	}, nil
}

Attacker <- "attacker" _ '[' _ Type:AttackerType _ ']' _ {
	return Type, nil
}

AttackerType <- ("active"/"passive") {
	return string(c.text), nil
}

Block <- Comment* Block:(Principal/Message/Phase) _ Comment* {
	return Block, nil
}

Principal <- "principal" _ Name:PrincipalName _ '[' _ Expressions:(Expression*) _ ']' _ {
	e  := Expressions.([]interface{})
	de := make([]expression, len(e))
	for i, v := range e { de[i] = v.(expression) }
	return block{
		kind: "principal",
		principal: principal {
			name: Name.(string),
			expressions: de,
		},
	}, nil
}

PrincipalName <- Name:Identifier {
	err := parserCheckIfReserved(Name.(string))
	return strings.Title(Name.(string)), err
}

Qualifier <- ("public"/"private"/"password") {
	return string(c.text), nil
}

Message <- Sender:PrincipalName _ "->" _ Recipient:PrincipalName _ ':' _ Constants:MessageConstants {
	return block{
		kind: "message",
		message: message{
			sender: Sender.(string),
			recipient: Recipient.(string),
			constants: Constants.([]constant),
		},
	}, nil
}

MessageConstants <- MessageConstants:(GuardedConstant/Constant)+ {
	var da []constant
	a  := MessageConstants.([]interface{})
	for _, v := range a {
		c := v.(value).constant
		da = append(da, c)
	}
	return da, nil
}

Expression <- Comment* Expression:(Knows/Generates/Leaks/Assignment) _ Comment* {
	return Expression, nil
}

Knows <- "knows" _ Qualifier:Qualifier _ Constants:Constants {
	return expression{
		kind: "knows",
		qualifier: Qualifier.(string),
		constants: Constants.([]constant),
	}, nil
}

Generates <- "generates" _ Constants:Constants {
	return expression{
		kind: "generates",
		qualifier: "",
		constants: Constants.([]constant),
	}, nil
}

Leaks <- "leaks" _ Constants:Constants {
	return expression{
		kind: "leaks",
		qualifier: "",
		constants: Constants.([]constant),
	}, nil
}

Assignment <- Left:Constants _ '=' _ Right:Value {
	switch Right.(value).kind {
	case "constant":
		err := errors.New("cannot assign value to value")
		return nil, err
	}
	return expression{
		kind: "assignment",
		left: Left.([]constant),
		right:  Right.(value),
	}, nil
}

Constant <- Constant:Identifier (_ ',' _)? {
	return value{
		kind: "constant",
		constant: constant{
			name: Constant.(string),
		},
	}, nil
}

Constants <- Constants:Constant+ {
	var da []constant
	var err error
	a  := Constants.([]interface{})
	for _, c := range a {
		err = parserCheckIfReserved(c.(value).constant.name)
		if err != nil { break }
		da = append(da, c.(value).constant)
	}
	return da, err
}

Phase <- "phase" _ '[' _ Number:[0-9]+ _ ']' _ {
	a  := Number.([]interface{})
	da := make([]uint8, len(a))
	for i, v := range a { da[i] = v.([]uint8)[0] }
	n, err := strconv.Atoi(b2s(da))
	return block{
		kind: "phase",
		phase: phase{
			number: n,
		},
	}, err
}

GuardedConstant <- '[' Guarded:Identifier ']' (_ ',' _)? {
	err := parserCheckIfReserved(Guarded.(string))
	return value{
		kind: "constant",
		constant: constant{
			name: Guarded.(string),
			guard: true,
		},
	}, err
}

Primitive <- Name:PrimitiveName '(' _ Arguments:Value+ _ ')' Check:'?'? (_ ',' _)? {
	args := []value{}
	for _, a := range Arguments.([]interface{}) {
		args = append(args, a.(value))
	}
	return value{
		kind: "primitive",
		primitive: primitive{
			name: Name.(string),
			arguments: args,
			output: 0,
			check: Check != nil,
		},
	}, nil
}

PrimitiveName <- Name:Identifier {
	return strings.ToUpper(Name.(string)), nil
}

Equation <- First:Constant (_ '^' _) Second:Constant {
	return value{
		kind: "equation",
		equation: equation{
			values: []value{
				First.(value),
				Second.(value),
			},
		},
	}, nil
}

Value <- Primitive/Equation/Constant
	
Queries <- "queries" _ '[' _ Queries:(Query*) ']' _ {
	return Queries, nil
}

Query <- Comment* Query:(QueryConfidentiality/QueryAuthentication) Comment* {
	return Query, nil
}
	
QueryConfidentiality <- "confidentiality?" _ Constant:Constant _ Options:QueryOptions? _ {
	if Options == nil {
		Options = []queryOption{}
	}
	return query{
		kind: "confidentiality",
		constant: Constant.(value).constant,
		message: message{},
		options: Options.([]queryOption),
	}, nil
}

QueryAuthentication <- "authentication?" _ Message:Message _ Options:QueryOptions? _ {
	if Options == nil {
		Options = []queryOption{}
	}
	return query{
		kind: "authentication",
		constant: constant{},
		message: (Message.(block)).message,
		options: Options.([]queryOption),
	}, nil
}

QueryOptions <- '[' _ Options:(QueryOption*) ']' _ {
	o := Options.([]interface{})
	do := make([]queryOption, len(o))
	for i, v := range o { do[i] = v.(queryOption) }
	return do, nil
}

QueryOption <- OptionName:Identifier _ '[' _ Message:Message _ ']' _ {
	return queryOption{
		kind: OptionName.(string),
		message: (Message.(block)).message,
	}, nil
}

Identifier <- Identifier:[a-zA-Z0-9_]+ {
	identifier := strings.ToLower(string(c.text))
	return identifier, nil
}

Comment <- _ "//" [^\n]* _

_ "whitespace" <- [ \t\n\r]*

EOF <- !.
