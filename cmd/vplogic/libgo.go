/* SPDX-FileCopyrightText: © 2019-2020 Nadim Kobeissi <nadim@symbolic.software>
 * SPDX-License-Identifier: GPL-3.0-only */
// 00000000000000000000000000000000

package vplogic

import "strings"

var libgo = strings.Join([]string{
	"/* SPDX-FileCopyrightText: © 2019-2020 Nadim Kobeissi <nadim@symbolic.software>",
	" * SPDX-License-Identifier: GPL-3.0-only */",
	"",
	"// Implementation Version: 0.0.1",
	"",
	"/* ---------------------------------------------------------------- *",
	" * PARAMETERS                                                       *",
	" * ---------------------------------------------------------------- */",
	"",
	"// nolint:deadcode,unused",
	"package main",
	"",
	"import (",
	"\t\"crypto/aes\"",
	"\t\"crypto/cipher\"",
	"\t\"crypto/hmac\"",
	"\t\"crypto/rand\"",
	"\t\"crypto/sha256\"",
	"\t\"fmt\"",
	"\t\"io\"",
	"\t\"math/big\"",
	"\t\"strings\"",
	"",
	"\t\"golang.org/x/crypto/chacha20poly1305\"",
	"\t\"golang.org/x/crypto/curve25519\"",
	"\t\"golang.org/x/crypto/ed25519\"",
	"\t\"golang.org/x/crypto/hkdf\"",
	"\t\"golang.org/x/crypto/scrypt\"",
	")",
	"",
	"/* ---------------------------------------------------------------- *",
	" * ELLIPTIC CURVE CRYPTOGRAPHY                                      *",
	" * ---------------------------------------------------------------- */",
	"",
	"func x25519DhFromEd25519PublicKey(private_key []byte, public_key []byte) ([]byte, error) {",
	"\treturn curve25519.X25519(private_key, public_key)",
	"}",
	"",
	"func ed25519Gen() ([]byte, []byte, error) {",
	"\tpublic_key, private_key, err := ed25519.GenerateKey(rand.Reader)",
	"\tif err != nil {",
	"\t\treturn public_key, private_key, err",
	"\t}",
	"\treturn private_key, public_key, nil",
	"}",
	"",
	"func ed25519PublicKeyToCurve25519(pk ed25519.PublicKey) []byte {",
	"\t/* SPDX-PackageCopyrightText: Copyright 2019 Google LLC",
	"\t * SPDX-License-Identifier: BSD-3-Clause */",
	"\tvar curve25519P, _ = new(big.Int).SetString(strings.Join([]string{",
	"\t\t\"578960446186580977117854925043439539266\",",
	"\t\t\"34992332820282019728792003956564819949\",",
	"\t}, \"\"), 10)",
	"\tbigEndianY := make([]byte, ed25519.PublicKeySize)",
	"\tfor i, b := range pk {",
	"\t\tbigEndianY[ed25519.PublicKeySize-i-1] = b",
	"\t}",
	"\tbigEndianY[0] &= 127",
	"\ty := new(big.Int).SetBytes(bigEndianY)",
	"\tdenom := big.NewInt(1)",
	"\tdenom.ModInverse(denom.Sub(denom, y), curve25519P)",
	"\tu := y.Mul(y.Add(y, big.NewInt(1)), denom)",
	"\tu.Mod(u, curve25519P)",
	"\tout := make([]byte, 32)",
	"\tuBytes := u.Bytes()",
	"\tfor i, b := range uBytes {",
	"\t\tout[len(uBytes)-i-1] = b",
	"\t}",
	"\treturn out",
	"}",
	"",
	"/* ---------------------------------------------------------------- *",
	" * PRIMITIVES                                                       *",
	" * ---------------------------------------------------------------- */",
	"",
	"func ASSERT(a []byte, b []byte) bool {",
	"\treturn hmac.Equal(a, b)",
	"}",
	"",
	"func CONCAT(a ...[]byte) []byte {",
	"\tb := []byte{}",
	"\tfor _, aa := range a {",
	"\t\tb = append(b, aa...)",
	"\t}",
	"\treturn b",
	"}",
	"",
	"func SPLIT2(b []byte) ([]byte, []byte) {",
	"\ta1 := b[00:32]",
	"\ta2 := b[32:64]",
	"\treturn a1, a2",
	"}",
	"",
	"func SPLIT3(b []byte) ([]byte, []byte, []byte) {",
	"\ta1 := b[00:32]",
	"\ta2 := b[32:64]",
	"\ta3 := b[64:96]",
	"\treturn a1, a2, a3",
	"}",
	"",
	"func SPLIT4(b []byte) ([]byte, []byte, []byte, []byte) {",
	"\ta1 := b[00:32]",
	"\ta2 := b[32:64]",
	"\ta3 := b[64:96]",
	"\ta4 := b[96:128]",
	"\treturn a1, a2, a3, a4",
	"}",
	"",
	"func SPLIT5(b []byte) ([]byte, []byte, []byte, []byte, []byte) {",
	"\ta1 := b[00:32]",
	"\ta2 := b[32:64]",
	"\ta3 := b[64:96]",
	"\ta4 := b[96:128]",
	"\ta5 := b[128:160]",
	"\treturn a1, a2, a3, a4, a5",
	"}",
	"",
	"func HASH(a ...[]byte) []byte {",
	"\tb := []byte{}",
	"\tfor _, aa := range a {",
	"\t\tb = append(b, aa...)",
	"\t}",
	"\th := sha256.Sum256(b)",
	"\treturn h[:]",
	"}",
	"",
	"func MAC(k []byte, message []byte) ([]byte, error) {",
	"\tmac := hmac.New(sha256.New, k)",
	"\t_, err := mac.Write(message)",
	"\treturn mac.Sum(nil), err",
	"}",
	"",
	"func HKDF1(ck []byte, ikm []byte) ([]byte, error) {",
	"\tk1 := make([]byte, 32)",
	"\toutput := hkdf.New(sha256.New, ikm, ck, []byte{})",
	"\t_, err := io.ReadFull(output, k1)",
	"\treturn k1, err",
	"}",
	"",
	"func HKDF2(ck []byte, ikm []byte) ([]byte, []byte, error) {",
	"\tk1 := make([]byte, 32)",
	"\tk2 := make([]byte, 32)",
	"\toutput := hkdf.New(sha256.New, ikm, ck, []byte{})",
	"\t_, err := io.ReadFull(output, k1)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k2)",
	"\treturn k1, k2, err",
	"}",
	"",
	"func HKDF3(ck []byte, ikm []byte) ([]byte, []byte, []byte, error) {",
	"\tk1 := make([]byte, 32)",
	"\tk2 := make([]byte, 32)",
	"\tk3 := make([]byte, 32)",
	"\toutput := hkdf.New(sha256.New, ikm, ck, []byte{})",
	"\t_, err := io.ReadFull(output, k1)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k2)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k3)",
	"\treturn k1, k2, k3, err",
	"}",
	"",
	"func HKDF4(ck []byte, ikm []byte) ([]byte, []byte, []byte, []byte, error) {",
	"\tk1 := make([]byte, 32)",
	"\tk2 := make([]byte, 32)",
	"\tk3 := make([]byte, 32)",
	"\tk4 := make([]byte, 32)",
	"\toutput := hkdf.New(sha256.New, ikm, ck, []byte{})",
	"\t_, err := io.ReadFull(output, k1)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k2)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k3)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k4)",
	"\treturn k1, k2, k3, k4, err",
	"}",
	"",
	"func HKDF5(ck []byte, ikm []byte) ([]byte, []byte, []byte, []byte, []byte, error) {",
	"\tk1 := make([]byte, 32)",
	"\tk2 := make([]byte, 32)",
	"\tk3 := make([]byte, 32)",
	"\tk4 := make([]byte, 32)",
	"\tk5 := make([]byte, 32)",
	"\toutput := hkdf.New(sha256.New, ikm, ck, []byte{})",
	"\t_, err := io.ReadFull(output, k1)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k2)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k3)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k4)",
	"\tif err != nil {",
	"\t\treturn []byte{}, []byte{}, []byte{}, []byte{}, []byte{}, err",
	"\t}",
	"\t_, err = io.ReadFull(output, k5)",
	"\treturn k1, k2, k3, k4, k5, err",
	"}",
	"",
	"func PW_HASH(a ...[]byte) ([]byte, error) {",
	"\th := HASH(a...)",
	"\tsalt := make([]byte, 16)",
	"\t_, err := rand.Read(salt)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tdk, err := scrypt.Key(h, salt, 32768, 8, 1, 32)",
	"\treturn dk, err",
	"}",
	"",
	"func ENC(k []byte, plaintext []byte) ([]byte, error) {",
	"\tblock, err := aes.NewCipher(k)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tiv := make([]byte, aes.BlockSize)",
	"\t_, err = rand.Read(iv)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tmode := cipher.NewCBCEncrypter(block, iv)",
	"\tciphertext := make([]byte, len(plaintext))",
	"\tmode.CryptBlocks(ciphertext, plaintext)",
	"\treturn append(iv, ciphertext...), nil",
	"}",
	"",
	"func DEC(k []byte, ciphertext []byte) ([]byte, error) {",
	"\tblock, err := aes.NewCipher(k)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tif len(ciphertext)%aes.BlockSize != 0 {",
	"\t\treturn []byte{}, fmt.Errorf(\"invalid ciphertext\")",
	"\t}",
	"\tif len(ciphertext) < aes.BlockSize {",
	"\t\treturn []byte{}, fmt.Errorf(\"invalid ciphertext\")",
	"\t}",
	"\tiv := ciphertext[:aes.BlockSize]",
	"\tmode := cipher.NewCBCDecrypter(block, iv)",
	"\tplaintext := make([]byte, len(ciphertext[aes.BlockSize:]))",
	"\tmode.CryptBlocks(plaintext, ciphertext)",
	"\treturn plaintext, nil",
	"}",
	"",
	"func AEAD_ENC(k []byte, plaintext []byte, ad []byte) ([]byte, error) {",
	"\tnonce := make([]byte, chacha20poly1305.NonceSizeX)",
	"\t_, err := rand.Read(nonce)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tenc, _ := chacha20poly1305.NewX(k)",
	"\tciphertext := enc.Seal(nil, nonce, plaintext, ad)",
	"\treturn append(nonce, ciphertext...), nil",
	"}",
	"",
	"func AEAD_DEC(k []byte, ciphertext []byte, ad []byte) ([]byte, error) {",
	"\tenc, err := chacha20poly1305.NewX(k)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tnonce := ciphertext[:chacha20poly1305.NonceSizeX]",
	"\tif len(ciphertext) <= chacha20poly1305.NonceSizeX {",
	"\t\treturn []byte{}, fmt.Errorf(\"authenticated decryption failed\")",
	"\t}",
	"\tplaintext, err := enc.Open(",
	"\t\tnil, nonce,",
	"\t\tciphertext[chacha20poly1305.NonceSizeX:], ad,",
	"\t)",
	"\treturn plaintext, err",
	"}",
	"",
	"func PKE_ENC(pk []byte, plaintext []byte) ([]byte, error) {",
	"\tesk, epk, err := ed25519Gen()",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tss, err := x25519DhFromEd25519PublicKey(esk, pk)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tciphertext, err := ENC(HASH(ss), plaintext)",
	"\treturn append(epk, ciphertext...), err",
	"}",
	"",
	"func PKE_DEC(k []byte, ciphertext []byte) ([]byte, error) {",
	"\tif len(ciphertext) <= 32 {",
	"\t\treturn []byte{}, fmt.Errorf(\"invalid ciphertext\")",
	"\t}",
	"\tepk := ciphertext[:32]",
	"\tss, err := x25519DhFromEd25519PublicKey(k, epk)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\tplaintext, err := DEC(HASH(ss), ciphertext)",
	"\treturn plaintext, err",
	"}",
	"",
	"func SIGN(k []byte, message []byte) []byte {",
	"\treturn ed25519.Sign(k, message)",
	"}",
	"",
	"func SIGNVERIF(pk []byte, message []byte, signature []byte) bool {",
	"\treturn ed25519.Verify(pk, message, signature)",
	"}",
	"",
	"func RINGSIGN(ka []byte, kb []byte, kc []byte, message []byte) []byte {",
	"\treturn []byte{}",
	"}",
	"",
	"func RINGSIGNVERIF(pka []byte, pkb []byte, pkc []byte, message []byte, signature []byte) bool {",
	"\treturn false",
	"}",
	"",
	"func BLIND(k []byte, message []byte) []byte {",
	"\treturn []byte{}",
	"}",
	"",
	"func UNBLIND(k []byte, message []byte, signature []byte) []byte {",
	"\treturn []byte{}",
	"}",
	"",
	"func SHAMIR_SPLIT(x []byte) []byte {",
	"\treturn []byte{}",
	"}",
	"",
	"func SHAMIR_JOIN(a []byte, b []byte, c []byte) []byte {",
	"\treturn []byte{}",
	"}",
	"",
	"func GENERATES() ([]byte, error) {",
	"\tb := make([]byte, 32)",
	"\t_, err := rand.Read(b)",
	"\tif err != nil {",
	"\t\treturn []byte{}, err",
	"\t}",
	"\treturn b, nil",
	"}",
	"",
	"/* ---------------------------------------------------------------- *",
	" * STATE MANAGEMENT                                                 *",
	" * ---------------------------------------------------------------- */",
	"",
	"/* ---------------------------------------------------------------- *",
	" * PROCESSES                                                        *",
	" * ---------------------------------------------------------------- */",
	""},
	"\n")
